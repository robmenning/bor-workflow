## doto 
-- add tables for fund* and series* for pooled level data
-- PortTran.SimId smallint UNSIGNED, -- simulation id: todo: create sim-related tables
-- add tables for tax lot related data


## context
This project/repository is one of several that together make up the "bor" (for Book of Record) system.
See the repository 'bor-app' .cursorrules for the overall application context and requirements.

This project creates MYSQL 8 databases for an application called "bor" (for Book of Record).

## technical overview
This project will create two (or more) MYSQL 8 databases on a single instance (or Docker container). 
The database creation for each database will involve running a series of SQL scripts to 
- create the database
- create the schema
- create the users
- create the permissions
- create the tables
- create the procedures, functions, triggers, views, etc.
- load initial data 
A docker network called 'bor-network' will be created to allow the containers to communicate with each other.


The project will have scripts in the ./script/init directory for the above mentioned database DDL and DML commands and scripts in ./script/ 
for starting, monitoring, and stopping the Docker containers, as well as for backing up the databases.


- * consider caching layer between API and database. 
- * consider ProxySQL between API and database can provide caching, connection pooling, and query routing

## databases created

- bor
   . application database
   . responsible for storing information about the system's applications, clients, users, roles, permissions. 
   . prisma tables in 'bor' database for RBAC: 
      ..PrismaUser
      ..Account
      ..Session
      ..VerificationToken
      ..Role
      ..Permission
      ..UserRole
      ..RolePermission
      ..AuthActivity
- borinst
   . responsible for investment related data for the investment management modules
- borarch
   . raw data for ETL
   . archived (high avail latentcy) data
- bormeta
   . metadata for bor-workflow (jobs, queue, status, result)
   . validation data
   . data process rule data (similar to ETL) for bor-etl
   . consider integrating with rules engine for data validation and portfolio compliance checking 

- * consider caching layer between API and database. 
- * consider ProxySQL between API and database can provide caching, connection pooling, and query routing

## implementation of docker volumes
The MySQL database uses a file-per-table approach with InnoDB for optimal performance and data isolation. We've implemented a structure with separate volumes for data and tablespaces:

1. A primary Docker volume (`bor-volume`) is mounted to `/var/lib/mysql` containing all MySQL system tables and database directories
2. A secondary Docker volume (`bor-tablespaces`) is mounted to `/tablespaces` containing all tablespace files
3. A shared volume (`bor-files-data`) for ETL file processing:
   - Mounted at `/var/lib/mysql-files` in bor-db for MySQL file operations
   - Used for sharing files between containers for ETL workflows
4. Each database uses a dedicated tablespace (`ts_bor`, `ts_borinst`, `ts_borarch`, `ts_bormeta`)
5. Each table has its own `.ibd` file within the database directory structure

This approach offers several advantages:
- Physical separation of data files for better I/O isolation
- Ability to back up database files and tablespaces independently
- Flexibility in implementing different backup strategies per database
- Efficient storage utilization and performance
- Shared file access for ETL workflows across containers

### Data Storage Structure
```
/var/lib/mysql/           # Main data directory (bor-volume)
├── bor/                  # bor database directory
│   ├── Account.ibd       # Each table has its own file
│   ├── AuthActivity.ibd
│   ├── Permission.ibd
│   └── ...
├── borinst/              # borinst database directory
│   ├── Instrument.ibd
│   └── Portfolio.ibd
├── borarch/              # borarch database directory
│   ├── HistoricalData.ibd
│   └── RawData.ibd
└── bormeta/              # bormeta database directory
    ├── ETLJob.ibd
    └── ValidationRule.ibd

/tablespaces/             # Tablespace directory (bor-tablespaces)
├── bor.ibd               # bor tablespace file
├── borinst.ibd           # borinst tablespace file
├── borarch.ibd           # borarch tablespace file
└── bormeta.ibd           # bormeta tablespace file

/var/lib/mysql-files/     # ETL files directory (bor-files-data)
├── ftpetl/              # FTP user directory
│   ├── incoming/        # New files uploaded here
│   ├── processed/       # Files after processing
│   └── archive/         # Archived files
├── users/               # User-specific directories
├── inbound/             # Inbound file processing
└── ...                  # Other directories as needed

/home/sftp/              # Symbolic link to /var/lib/mysql-files
└── [same structure as /var/lib/mysql-files]
```

### Volume Creation and Management
Volumes are created and managed through the `db-start.sh` script:

```bash
# Create volumes
docker volume create bor-volume
docker volume create bor-tablespaces
docker volume create bor-files-data

# Set permissions and create directory structure
docker run --rm -v bor-tablespaces:/tablespaces alpine sh -c "mkdir -p /tablespaces && chmod 777 /tablespaces"
docker run --rm -v bor-files-data:/etl-files alpine sh -c "
  mkdir -p /etl-files/ftpetl /etl-files/users /etl-files/inbound && 
  chmod 770 /etl-files && 
  chown mysql:mysql /etl-files && 
  ln -s /var/lib/mysql-files /home/sftp
"
```

### Volume Mounting in Container
The volumes are mounted in the container with the following configuration:

```bash
docker run --name bor-db \
  -v bor-volume:/var/lib/mysql \
  -v bor-tablespaces:/tablespaces \
  -v bor-files-data:/var/lib/mysql-files \
  ...
```

### File Access and Permissions
The container is configured with the following file access settings:

1. **Directory Permissions**:
   - ETL files directory: 770 (drwxrwx---)
   - Tablespaces directory: 777 (drwxrwxrwx)

2. **MySQL Configuration**:
   - secure_file_priv set to /var/lib/mysql-files
   - local_infile enabled for LOAD DATA INFILE operations

3. **Directory Structure**:
   - /var/lib/mysql-files: Primary file access directory
   - /home/sftp: Symbolic link to /var/lib/mysql-files
   - Both paths are accessible for LOAD DATA INFILE operations

4. **File Access**:
   - MySQL runs as the mysql user inside the container
   - Files should be placed in /var/lib/mysql-files for LOAD DATA INFILE operations
   - The symbolic link at /home/sftp provides an alternative access point

### Volume Considerations for Other Containers
When developing other containers in the bor system that need to interact with these volumes:

1. **Database Access**: Other containers should connect to the MySQL instance using the container name `bor-db` as the hostname
2. **File Sharing**: For ETL workflows, mount the `bor-files-data` volume at an appropriate location in your container
3. **Permissions**: Ensure proper permissions are set on mounted volumes
4. **Backup Coordination**: Coordinate backup strategies with the database container to ensure data consistency
5. **Network**: Ensure containers are on the same Docker network (`bor-network`) for proper communication
6. **File Access**: When using LOAD DATA INFILE, files can be placed in either /var/lib/mysql-files or /home/sftp
7. **Directory Structure**: Follow the established directory structure for file organization

## testing 
# DEV ITERATION LOOP
clear && ./script/db-stop.sh && ./script/db-start.sh --env development && docker ps && docker logs bor-db 
clear && ./script/db-stop.sh && ./script/db-start.sh --resetall --env development && docker ps && docker logs bor-db #### be careful with --resetall as it will destroy all data

#  PROD ITERATION LOOP
clear && ./script/db-stop.sh && ./script/db-start.sh --env production && docker ps && docker logs bor-db



# check db contents after creation
docker exec bor-db mysql -u borAdmin -pAye3aBYrXF -e "USE bor; SELECT COUNT(*) FROM Role;"

# check separate volumes (should see innoDB files):
docker exec -it bor-db bash -c "ls -la /var/lib/mysql-bor /var/lib/mysql-borinst /var/lib/mysql-borarch /var/lib/mysql-bormeta"

# verfiy database creation:
docker exec -it bor-db mysql -u root -p${MYSQL_ROOT_PASSWORD} -e "SHOW VARIABLES LIKE 'innodb_file_per_table'"
docker exec -it bor-db mysql -u root -p${MYSQL_ROOT_PASSWORD} -e "SELECT table_schema, table_name, data_free FROM information_schema.tables WHERE table_schema IN ('bor', 'borinst', 'borarch', 'bormeta')"

# check if we can connect with the root password:
docker exec -it bor-db mysql -u root -pCA4DYCpM8T -e "SHOW DATABASES;"

# check if the users were created:
docker exec -it bor-db mysql -u root -pCA4DYCpM8T -e "SELECT User, Host FROM mysql.user;"


# verify the users work by trying to connect with one of them
docker exec -it bor-db mysql -u borAdmin -pAye3aBYrXF -e "SHOW DATABASES;"

# check if the tables were created
docker exec -it bor-db mysql -u borAdmin -pAye3aBYrXF -e "USE bor; SHOW TABLES;"

# check where the data is stored
docker exec -it bor-db ls -la /var/lib/mysql-bor/ /var/lib/mysql-borinst/ /var/lib/mysql-borarch/ /var/lib/mysql-bormeta/

# check where the database files actually are
docker exec -it bor-db mysql -u root -pCA4DYCpM8T -e "SELECT table_schema, table_name, engine, data_free, index_length, data_length FROM information_schema.tables WHERE table_schema IN ('bor', 'borinst', 'borarch', 'bormeta') LIMIT 5;"

# check the actual location of data files
docker exec -it bor-db find /var/lib/mysql -name "*.ibd" | head -5

# Run initialization scripts separately in container (for debugging)
# Note: Replace CA4DYCpM8T with your actual root password from environment variables
docker exec -i bor-db mysql -u root -pCA4DYCpM8T < script/init/0.setup-dirs.sh
docker exec -i bor-db mysql -u root -pCA4DYCpM8T < script/init/1.ddl-create-db.sql
docker exec -i bor-db mysql -u root -pCA4DYCpM8T < script/init/2.create-tablespaces.sql
docker exec -i bor-db mysql -u root -pCA4DYCpM8T < script/init/3.ddl-bor-tables.sql
docker exec -i bor-db mysql -u root -pCA4DYCpM8T < script/init/4.dml-prisma-seed.sql
docker exec -i bor-db mysql -u root -pCA4DYCpM8T < script/init/5.ddl-borinst-tables.sql
docker exec -i bor-db mysql -u root -pCA4DYCpM8T < script/init/6.dml-borinst-init.sql
docker exec -i bor-db mysql -u root -pCA4DYCpM8T < script/init/7.procs-port.sql



## deployment 
The project will be deployed using standard Docker techniques, but not using Docker Compose which is not supported in some target environments.
The project will be deployed using a CI/CD pipeline to a target environment.
The deployment to a bare-metal MySQL 8 instance and to the target Docker container will use the same set of database DDL and DML scripts and configuration files.

# to set up a user with all roles:
docker exec -it bor-db mysql -u borAllAdmin -pkBu9pjz2vi -e "insert into UserRole (id, userId, roleId) select concat(r.id, ':', pu.id) as id, pu.id as userId, r.id as roleId from PrismaUser pu join Role r on 1=1 where pu.email = 'robmenning@gmail.com';"
or
docker exec -it bor-db mysql -u borAllSvc -pu67nyNgomZ -e "insert into UserRole (id, userId, roleId) select concat(r.id, ':', pu.id) as id, pu.id as userId, r.id as roleId from PrismaUser pu join Role r on 1=1 where pu.email = 'robmenning@gmail.com';"


## MySQL Database Container Technical Summary for API Integration

### Container Details
- **Container Name**: `bor-db`
- **Image**: `mysql:8.0`
- **Network**: Connected to `bor-network` (custom Docker network)
- **Port Mapping**: Host port `${DB_PORT:-3310}` mapped to container port `3306`
- **Volume**: Uses `bor-volume` for persistent data storage

### Database Configuration
- **Authentication**: Uses MySQL native password authentication
- **Character Set**: `utf8mb4` with `utf8mb4_unicode_ci` collation
- **Binary Logging**: Enabled with `log-bin-trust-function-creators=1`
- **Custom Config**: Mounted from `./script/config/my.cnf`

### Databases
1. **bor**: Primary application database
   - Contains application configuration, user management, and authentication tables
   - Admin user: `borAdmin` with password from environment variables

2. **borinst**: Investment management database
   - Contains financial data, portfolios, instruments, transactions
   - Admin user: `borinstAdmin` with password from environment variables

### API Connection Details
- **Connection String**: When connecting from another container on the same network:
  - Host: `bor-db` (container name as hostname)
  - Port: `3306` (MySQL default port)
  - No need to use the mapped port when connecting within the Docker network

### Authentication Options
- **Application User**: `borAdmin` for the `bor` database
- **Investment User**: `borinstAdmin` for the `borinst` database
- **Root User**: Available with password from `MYSQL_ROOT_PASSWORD` environment variable

### Schema Features
- **Stored Procedures**: Comprehensive CRUD operations with error handling
- **Triggers**: Used for history tracking and data validation
- **Foreign Keys**: Extensive relational integrity constraints
- **Transactions**: All procedures use transactions for data integrity

### Network Considerations
- Use the container name `bor-db` as the hostname in your connection string
- Ensure your API container is also connected to the `bor-network`
- Example connection in Node.js:
  ```javascript
  const connection = mysql.createConnection({
    host: 'bor-db',
    port: 3306,
    user: 'borAdmin',
    password: process.env.BOR_DB_PASSWORD,
    database: 'bor'
  });
  ```
